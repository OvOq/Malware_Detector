from PIL import Image
import numpy as np
import math

# 核, 产生16个像素点不同的权重
def BiBubic(x):
    x=abs(x)
    if x<=1:
        return 1-2*(x**2)+(x**3)
    elif x<2:    
        return 4-8*x+5*(x**2)-(x**3)
    else:
        return 0    

# 双三次插值算法
# dstH为目标图像的高，dstW为目标图像的宽
def BiCubic_interpolation(img,dstH,dstW):
    # scrH,scrW,_=img.shape
    scrH,scrW=img.shape
    #img=np.pad(img,((1,3),(1,3),(0,0)),'constant')
    retimg=np.zeros((dstH,dstW,3),dtype=np.uint8)
    for i in range(dstH):
        for j in range(dstW):
            scrx=i*(scrH/dstH)
            scry=j*(scrW/dstW)
            x=math.floor(scrx)
            y=math.floor(scry)
            u=scrx-x
            v=scry-y
            tmp=0
            for ii in range(-1,2):
                for jj in range(-1,2):
                    if x+ii<0 or y+jj<0 or x+ii>=scrH or y+jj>=scrW:
                        continue
                    tmp+=img[x+ii,y+jj]*BiBubic(ii-u)*BiBubic(jj-v)
            retimg[i,j]=np.clip(tmp,0,255)
    return retimg

# im_path='E:/0/3dmeditor.exe_201227_153639.png'
print('JPG: ')
im_path='E:/0/1.jpg'
image_1 = np.array(Image.open(im_path))
print(image_1)
print(image_1.shape[0])
print(image_1.shape[1])
expH = image_1.shape[0] * 2
expW = image_1.shape[1] * 2
print(expH)
print(expW)
# image2 = BiCubic_interpolation(image_1, expH, expW)

print('PNG: ')
im_path1='E:/0/2.jpg'
image_2 = np.array(Image.open(im_path1))
print(image_2)
print(image_2.shape[0])
print(image_2.shape[1])
expH2 = int((image_2.shape[0]))
expW2 = image_2.shape[1]
print(expH2)
print(expW2)
# print()
# image2 = BiCubic_interpolation(image_2, expH, expW)
# image2=Image.fromarray(image_2.astype('uint8')).convert('RGB')
# image2.save('E:/0/T2.png')


# image2 = BiCubic_interpolation(image, image.shape[0] * 2, image.shape[1] * 2)

# image2=BiCubic_interpolation(image,image.shape[0]*2,image.shape[1]*2)
# image2=Image.fromarray(image2.astype('uint8')).convert('RGB')
# image2.save('E:/0/T3dmeditor.exe_201227_153639.png')